diff --git a/plotter_electricField.py b/plotter_electricField.py
index 3d4de06..58cba9e 100644
--- a/plotter_electricField.py
+++ b/plotter_electricField.py
@@ -1,479 +1,341 @@
 import numpy as np
 import matplotlib.pyplot as plt
-from mpl_toolkits.mplot3d import Axes3D
-import os
-import sys
-from datetime import datetime
-from colorama import init, Fore, Style
-
-# Initialize colorama for cross-platform colored terminal output
-init()
-
-# Configuration Section
-# =====================
-
-# Plot parameters
-PLOT_CONFIG = {
-    "dpi": 200,
-    "font_size": 12,
-    "legend_font_size": 10,
-    "tick_label_size": 10,
-    "figure_size": (12, 10),
-    "colorbar_pad": 0.1,
-    "output_folder": os.path.join("Plots", "EField_Plots"),
-    "show_plots": False,
-}
-
-# Physical constants
+import plotly.graph_objects as go
+from mayavi import mlab
+import pyvista as pv
+import holoviews as hv
+from holoviews import opts
+
+# Initialize HoloViews with the Bokeh backend
+hv.extension('bokeh')
+pv.global_theme.allow_empty_mesh = True
+
+# Enable or disable specific visualizations
+MATPLOTLIB_2D_STREAM_CONTOUR = True
+MATPLOTLIB_2D_QUIVER = True
+MATPLOTLIB_2D_ELECTRIC_CONTOUR = True
+MATPLOTLIB_2D_POTENTIAL_CONTOUR = True
+MATPLOTLIB_3D_SURFACE = False
+PLOTLY_3D_SURFACE = False
+MAYAVI_VECTOR_FIELD = False
+PYVISTA_STREAMLINES = False
+HOLOVIEWS_QUAD_MESH = False
+
+# Physical and plot constants
 PHYSICS_PARAMS = {
-    "B0": 1.0,  # Magnetic field strength at the magnetic axis (T)
+    "B0": 1.0,  # Magnetic field strength (T)
     "r0": 1.0,  # Reference radius (m)
     "Phi0": 1.0,  # Reference electrostatic potential (V)
-    "kappa": 1.0,  # Temperature gradient parameter (dimensionless)
+    "kappa": 1.0,  # Temperature gradient parameter
     "r_star": 2.0,  # Characteristic radius for temperature profile (m)
-    "n0": 1.0,  # Reference density (m^-3)
-}
-
-# Plot-specific parameters
-PLOT_PARAMS = {
-    "3d_quiver": {
-        "grid_size": 15,
-        "R_range": (0.1, 5),  # Range of R values (m)
-        "Z_range": (0.1, 5),  # Range of Z values (m)
-        "quiver_length": 0.5,  # Length of quiver arrows
-    },
-    "3d_contour": {
-        "grid_size": 100,
-        "R_range": (0.1, 5),  # Range of R values (m)
-        "Z_range": (0.1, 5),  # Range of Z values (m)
-        "contour_levels": 20,
-        "view_angle": (25, 45),
-        "show_contour_info": False,
-    },
-    "2d_streamplot": {
-        "grid_size": 100,
-        "R_range": (0.1, 5),  # Range of R values (m)
-        "Z_range": (0.1, 5),  # Range of Z values (m)
-        "density": 1.5,
-        "linewidth": 1.5,
-        "arrowsize": 1.2,
-        "scale_factor": 1,  # Scale factor for streamlines
-        "minlength": 0.1,  # Minimum length of streamlines (m)
-        "start_points": None,  # Optional array of starting points for streamlines
-        "x_lim": (0.1, 5),  # x-axis limits (m)
-        "y_lim": (0.1, 5),  # y-axis limits (m)
-        "show_scale": False,  # Whether to show the scale annotation
-    },
-    "2d_contour": {
-        "grid_size": 100,
-        "R_range": (0.1, 5),  # Range of R values (m)
-        "Z_range": (0.1, 5),  # Range of Z values (m)
-        "contour_levels": 50,
-        "cmap": "viridis",  # Colormap to use
-        "show_contour_lines": False,  # Whether to show contour lines
-        "x_lim": (0.1, 5),  # x-axis limits (m)
-        "y_lim": (0.1, 5),  # y-axis limits (m)
-        "show_contour_info": False,  # Whether to show the contour levels annotation
-    },
 }
 
-
-# Helper functions
-
-
-def create_directory(path):
-    """Create a directory if it doesn't exist."""
-    try:
-        os.makedirs(path, exist_ok=True)
-        print(f"{Fore.GREEN}✔ Created directory: {path}{Style.RESET_ALL}")
-    except Exception as e:
-        print(
-            f"{Fore.RED}✘ Error creating directory {
-              path}: {e}{Style.RESET_ALL}"
-        )
-        sys.exit(1)
-
-
-def print_section(title):
-    """Print a formatted section title."""
-    print(f"\n{Fore.CYAN}{'=' * 40}")
-    print(f"{title:^40}")
-    print(f"{'=' * 40}{Style.RESET_ALL}")
-
-
-# Create output folders
-create_directory(PLOT_CONFIG["output_folder"])
-
-# Set up high-quality plot parameters
-plt.rcParams["figure.dpi"] = PLOT_CONFIG["dpi"]
-plt.rcParams["savefig.dpi"] = PLOT_CONFIG["dpi"]
-plt.rcParams["font.size"] = PLOT_CONFIG["font_size"]
-plt.rcParams["legend.fontsize"] = PLOT_CONFIG["legend_font_size"]
-plt.rcParams["xtick.labelsize"] = PLOT_CONFIG["tick_label_size"]
-plt.rcParams["ytick.labelsize"] = PLOT_CONFIG["tick_label_size"]
-
-# Functions
-
-
-def psi(R, z):
-    return (
-        PHYSICS_PARAMS["B0"]
-        * PHYSICS_PARAMS["r0"] ** 2
-        * (1 - z / np.sqrt(R**2 + z**2))
-    )
-
-
-def varsigma(R, z):
-    return 1 - (1 - psi(R, z) / (PHYSICS_PARAMS["B0"] * PHYSICS_PARAMS["r0"] ** 2)) ** 2
-
-
-def Phi_star(R, z):
-    return 0.5 * PHYSICS_PARAMS["Phi0"] * varsigma(R, z)
-
-
-def T_psi(R, z):
-    return (
-        PHYSICS_PARAMS["kappa"]
-        * PHYSICS_PARAMS["Phi0"]
-        * (
-            1
-            - (PHYSICS_PARAMS["r0"] ** 2 / PHYSICS_PARAMS["r_star"] ** 2)
-            * varsigma(R, z)
-        )
-    )
-
-
-def n(R, z):
-    return PHYSICS_PARAMS["n0"] * np.exp(
-        (Phi_star(R, z) - PHYSICS_PARAMS["Phi0"]) / T_psi(R, z)
+delta_star = PHYSICS_PARAMS["r0"] / PHYSICS_PARAMS["r_star"]
+
+# Define electric potential and field functions
+def Phi(R, Z):
+    term1 = PHYSICS_PARAMS["kappa"] * PHYSICS_PARAMS["Phi0"] * (
+        1 - delta_star**2 * (1 - Z**2 / (R**2 + Z**2))
+    ) * np.log(1 / (R**2 + Z**2))
+    term2 = 0.5 * PHYSICS_PARAMS["Phi0"] * (1 - Z**2 / (R**2 + Z**2))
+    return term1 + term2
+
+def E_R(R, Z):
+    Phi0 = PHYSICS_PARAMS["Phi0"]
+    kappa = PHYSICS_PARAMS["kappa"]
+    delta_star2 = delta_star**2
+    numerator = R * Phi0 * (
+        -2 * kappa * R**2 
+        + 2 * delta_star2 * kappa * (R**2 - Z**2 * np.log(1 / (R**2 + Z**2)))
+        + (1 - 2 * kappa) * Z**2
     )
-
-
-def E_R(R, z):
-    dR = 1e-6
-    return (
-        -(Phi_star(R + dR, z) - Phi_star(R, z)) / dR
-        - (T_psi(R, z) / n(R, z)) * (n(R + dR, z) - n(R, z)) / dR
-    )
-
-
-def E_z(R, z):
-    dz = 1e-6
-    return (
-        -(Phi_star(R, z + dz) - Phi_star(R, z)) / dz
-        - (T_psi(R, z) / n(R, z)) * (n(R, z + dz) - n(R, z)) / dz
+    denominator = (R**2 + Z**2)**2
+    return -numerator / denominator
+
+def E_z(R, Z):
+    Phi0 = PHYSICS_PARAMS["Phi0"]
+    kappa = PHYSICS_PARAMS["kappa"]
+    delta_star2 = delta_star**2
+    numerator = -Z * Phi0 * (
+        (2 * kappa + 1) * R**2 
+        - 2 * delta_star2 * kappa * R**2 * (np.log(1 / (R**2 + Z**2)) + 1)
+        + 2 * kappa * Z**2
     )
+    denominator = (R**2 + Z**2)**2
+    return -numerator / denominator
+
+# Matplotlib 2D Stream and Contour Plot
+def matplotlib_2d_stream_contour():
+    if MATPLOTLIB_2D_STREAM_CONTOUR:
+        fig, ax = plt.subplots(figsize=(10, 8))
+        R = np.linspace(0.1, 5, 100)
+        Z = np.linspace(0.1, 5, 100)
+        R, Z = np.meshgrid(R, Z)
+
+        E_R_values = E_R(R, Z)
+        E_z_values = E_z(R, Z)
+        E_magnitude = np.sqrt(E_R_values**2 + E_z_values**2)
+
+        streamplot = ax.streamplot(R, Z, E_R_values, E_z_values, color=E_magnitude, cmap="viridis", linewidth=1.5)
+        potential = Phi(R, Z)
+        contour = ax.contour(R, Z, potential, levels=20, colors="red", linewidths=0.5)
+        
+        equipotential_line = plt.Line2D([0], [0], color="red", lw=0.5, label="Equipotential Lines")
+        electric_field_line = plt.Line2D([0], [0], color="purple", lw=1.5, label="Electric Field Lines")
+        ax.legend(handles=[equipotential_line, electric_field_line], loc="upper right")
+
+        plt.colorbar(streamplot.lines, label="Electric field magnitude (V/m)", pad=0.1)
+        ax.set_title("Electric Field (2D Streamplot) with Equipotential Lines")
+        ax.set_xlabel("R (m)")
+        ax.set_ylabel("Z (m)")
+        plt.tight_layout()
+        plt.show()
 
-
-# Plotting functions
-
-
-def create_plot(plot_type, plot_func):
-    """Create and save a plot with error handling."""
-    print_section(f"Creating {plot_type} plot")
-    try:
-        plot_func()
-        print(
-            f"{Fore.GREEN}✔ {plot_type} plot created successfully{
-              Style.RESET_ALL}"
-        )
-    except Exception as e:
-        print(
-            f"{Fore.RED}✘ Error creating {
-              plot_type} plot: {e}{Style.RESET_ALL}"
-        )
-
-
-def save_plot(fig, plot_type):
-    """Save the plot with a timestamp in the filename and optionally display it."""
-    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
-    filename = f"{plot_type}_{timestamp}.png"
-    filepath = os.path.join(PLOT_CONFIG["output_folder"], filename)
-    fig.savefig(filepath, bbox_inches="tight")
-    print(f"{Fore.GREEN}✔ Plot saved: {filepath}{Style.RESET_ALL}")
-
-    if PLOT_CONFIG["show_plots"]:
+# Matplotlib 2D Quiver Plot
+def matplotlib_2d_quiver():
+    if MATPLOTLIB_2D_QUIVER:
+        fig, ax = plt.subplots(figsize=(10, 8))
+
+        # Dense grid for potential color map
+        R_dense = np.linspace(0.1, 5, 100)
+        Z_dense = np.linspace(0.1, 5, 100)
+        R_dense, Z_dense = np.meshgrid(R_dense, Z_dense)
+        potential = Phi(R_dense, Z_dense)
+        contourf = ax.contourf(R_dense, Z_dense, potential, levels=50, cmap="coolwarm", alpha=0.6)
+        plt.colorbar(contourf, ax=ax, label="Electric Potential (V)")
+
+        # Sparse grid for quiver arrows
+        R_sparse = np.linspace(0.3, 5, 30)
+        Z_sparse = np.linspace(0.3, 5, 30)
+        R_sparse, Z_sparse = np.meshgrid(R_sparse, Z_sparse)
+        E_R_values = E_R(R_sparse, Z_sparse)
+        E_z_values = E_z(R_sparse, Z_sparse)
+
+        # Quiver plot for electric field
+        quiver = ax.quiver(R_sparse, Z_sparse, E_R_values, E_z_values, color="black", angles="xy", scale_units="xy", scale=4, alpha=0.5)
+
+        # Create a custom legend entry for Electric Potential Contours using a dummy Line2D object
+        from matplotlib.lines import Line2D
+        contour_legend = Line2D([0], [0], color="black", linestyle="-", linewidth=0.3, label="Electric Equipotential Lines")
+        
+
+        # Set plot title and labels
+        ax.set_title("Electric Field (2D Quiver Plot) with Electric Potential Color Map")
+        ax.set_xlabel("R (m)")
+        ax.set_ylabel("Z (m)")
+
+        # Add both entries to the legend
+        ax.legend(handles=[contour_legend], loc="upper left")
+
+        plt.tight_layout()
         plt.show()
-    else:
-        plt.close(fig)
+        
+def matplotlib_2d_potential_contour():
+    fig, ax = plt.subplots(figsize=(10, 8))
 
+    # Define grid for contour plot
+    R = np.linspace(0.1, 5, 200)  # Increase resolution for smoother contours
+    Z = np.linspace(-5, 5, 200)
+    R, Z = np.meshgrid(R, Z)
+    potential = Phi(R, Z)
 
-def create_3d_quiver_plot():
-    fig = plt.figure(figsize=PLOT_CONFIG["figure_size"])
-    ax = fig.add_subplot(111, projection="3d")
+    # Plot filled contours
+    contourf = ax.contourf(R, Z, potential, levels=50, cmap="viridis", alpha=0.8)
+    colorbar = plt.colorbar(contourf, ax=ax, label="Electric Potential (V)")
 
-    R = np.linspace(
-        *PLOT_PARAMS["3d_quiver"]["R_range"], PLOT_PARAMS["3d_quiver"]["grid_size"]
-    )
-    Z = np.linspace(
-        *PLOT_PARAMS["3d_quiver"]["Z_range"], PLOT_PARAMS["3d_quiver"]["grid_size"]
-    )
-    R, Z = np.meshgrid(R, Z)
+    # Overlay contour lines for better visual clarity
+    contours = ax.contour(R, Z, potential, levels=10, colors="black", linewidths=0.5)
 
-    E_R_values = E_R(R, Z)
-    E_z_values = E_z(R, Z)
-    E_magnitude = np.sqrt(E_R_values**2 + E_z_values**2)
+    # Add labels for contour lines
+    ax.clabel(contours, inline=True, fontsize=8, fmt="%.1f V")
 
-    # Normalize the vectors
-    E_R_norm = E_R_values / E_magnitude
-    E_z_norm = E_z_values / E_magnitude
-
-    # Plot the quiver
-    quiver_length = PLOT_PARAMS["3d_quiver"]["quiver_length"]
-    ax.quiver(
-        R,
-        Z,
-        np.zeros_like(R),
-        E_R_norm,
-        E_z_norm,
-        np.zeros_like(R),
-        length=quiver_length,
-        normalize=True,
-    )
+    # Set plot title and axis labels
+    ax.set_title("2D Electric Potential Contour Plot", fontsize=14, weight="bold")
+    ax.set_xlabel("R (m)", fontsize=12)
+    ax.set_ylabel("Z (m)", fontsize=12)
 
-    ax.set_xlabel("R (m)")
-    ax.set_ylabel("Z (m)")
-    ax.set_zlabel("E-field direction")
-    ax.set_title("3D Quiver Plot of Electric Field")
+    # Set grid and limits for professional look
+    ax.grid(visible=True, linestyle="--", color="grey", alpha=0.3)
+    ax.set_xlim(0.1, 5)
+    ax.set_ylim(-5, 5)
 
+    # Adjust layout for a clean look
     plt.tight_layout()
-    save_plot(fig, "3d_quiver")
+    plt.show()
 
 
-def create_3d_contour_plot():
-    fig = plt.figure(figsize=PLOT_CONFIG["figure_size"])
-    ax = fig.add_subplot(111, projection="3d")
+def matplotlib_2d_electric_field_contour():
+    fig, ax = plt.subplots(figsize=(10, 8))
 
-    # Assuming R and Z are in meters
-    R = np.linspace(
-        *PLOT_PARAMS["3d_contour"]["R_range"], PLOT_PARAMS["3d_contour"]["grid_size"]
-    )
-    Z = np.linspace(
-        *PLOT_PARAMS["3d_contour"]["Z_range"], PLOT_PARAMS["3d_contour"]["grid_size"]
-    )
+    # Define grid for contour plot
+    R = np.linspace(0.1, 5, 200)
+    Z = np.linspace(-5, 5, 200)
     R, Z = np.meshgrid(R, Z)
 
-    E_R_values = E_R(R, Z)  # Assuming E_R returns values in V/m
-    E_z_values = E_z(R, Z)  # Assuming E_z returns values in V/m
+    # Calculate electric field components and magnitude
+    E_R_values = E_R(R, Z)
+    E_z_values = E_z(R, Z)
     E_magnitude = np.sqrt(E_R_values**2 + E_z_values**2)
 
-    surf = ax.plot_surface(
-        R, Z, E_magnitude, cmap="viridis", edgecolor="none", alpha=0.8
-    )
+    # Plot filled contours for electric field magnitude
+    contourf = ax.contourf(R, Z, E_magnitude, levels=50, cmap="plasma", alpha=0.8)
+    colorbar = plt.colorbar(contourf, ax=ax, label="Electric Field Magnitude (V/m)")
 
-    contour_levels = np.linspace(
-        E_magnitude.min(),
-        E_magnitude.max(),
-        PLOT_PARAMS["3d_contour"]["contour_levels"],
-    )
-    contours = ax.contour(
-        R,
-        Z,
-        E_magnitude,
-        levels=contour_levels,
-        cmap="inferno",
-        linewidths=0.5,
-        linestyles="solid",
-    )
+    # Overlay contour lines for electric field magnitude
+    contours = ax.contour(R, Z, E_magnitude, levels=10, colors="black", linewidths=0.5)
+    ax.clabel(contours, inline=True, fontsize=8, fmt="%.1f V/m")
 
-    cbar = fig.colorbar(
-        surf,
-        ax=ax,
-        label="Electric field magnitude (V/m)",
-        shrink=0.7,
-        aspect=10,
-        pad=0.01,
-    )
-    cbar.ax.tick_params(labelsize=PLOT_CONFIG["tick_label_size"])
-
-    ax.set_xlabel("R (m)")
-    ax.set_ylabel("Z (m)")
-    ax.set_zlabel("Electric Field Magnitude (V/m)")
-    ax.set_title("Electric Field Distribution (3D Contour)")
-
-    ax.view_init(
-        elev=PLOT_PARAMS["3d_contour"]["view_angle"][0],
-        azim=PLOT_PARAMS["3d_contour"]["view_angle"][1],
-    )
-
-    # Ensure the aspect ratio is correct
-    ax.set_box_aspect((np.ptp(R), np.ptp(Z), np.ptp(E_magnitude)))
-
-    # Set axis limits (optional, adjust as needed)
-    ax.set_xlim(PLOT_PARAMS["3d_contour"].get("x_lim", (R.min(), R.max())))
-    ax.set_ylim(PLOT_PARAMS["3d_contour"].get("y_lim", (Z.min(), Z.max())))
-    ax.set_zlim(
-        PLOT_PARAMS["3d_contour"].get("z_lim", (E_magnitude.min(), E_magnitude.max()))
-    )
+    # Set plot title and axis labels
+    ax.set_title("2D Electric Field Magnitude Contour Plot", fontsize=14, weight="bold")
+    ax.set_xlabel("R (m)", fontsize=12)
+    ax.set_ylabel("Z (m)", fontsize=12)
 
-    # Add a text annotation for the contour levels (optional)
-    if PLOT_PARAMS["3d_contour"].get("show_contour_info", True):
-        contour_info = f'Contour levels: {PLOT_PARAMS["3d_contour"]["contour_levels"]}'
-        ax.text2D(0.05, 0.95, contour_info, transform=ax.transAxes, fontsize=8)
+    # Set grid and limits for professional look
+    ax.grid(visible=True, linestyle="--", color="grey", alpha=0.3)
+    ax.set_xlim(0.1, 5)
+    ax.set_ylim(-5, 5)
 
+    # Adjust layout for a clean look
     plt.tight_layout()
-    save_plot(fig, "3d_contour")
-
-
-def create_2d_streamplot():
-    fig, ax = plt.subplots(figsize=PLOT_CONFIG["figure_size"])
-
-    # Assuming R and Z are in meters
-    R = np.linspace(
-        *PLOT_PARAMS["2d_streamplot"]["R_range"],
-        PLOT_PARAMS["2d_streamplot"]["grid_size"],
-    )
-    Z = np.linspace(
-        *PLOT_PARAMS["2d_streamplot"]["Z_range"],
-        PLOT_PARAMS["2d_streamplot"]["grid_size"],
-    )
-    R, Z = np.meshgrid(R, Z)
-
-    E_R_values = E_R(R, Z)  # Assuming E_R returns values in V/m
-    E_z_values = E_z(R, Z)  # Assuming E_z returns values in V/m
-    E_magnitude = np.sqrt(E_R_values**2 + E_z_values**2)
-
-    # Scale factor for streamlines (optional, adjust as needed)
-    scale_factor = PLOT_PARAMS["2d_streamplot"].get("scale_factor", 1)
-
-    streamplot = ax.streamplot(
-        R,
-        Z,
-        E_R_values,
-        E_z_values,
-        density=PLOT_PARAMS["2d_streamplot"]["density"],
-        color=E_magnitude,
-        cmap="viridis",
-        linewidth=PLOT_PARAMS["2d_streamplot"]["linewidth"],
-        arrowsize=PLOT_PARAMS["2d_streamplot"]["arrowsize"],
-        minlength=PLOT_PARAMS["2d_streamplot"].get("minlength", 0.1),
-        start_points=PLOT_PARAMS["2d_streamplot"].get("start_points", None),
-    )
+    plt.show()
+    
+    
+# Matplotlib 3D Surface Plot
+def matplotlib_3d_surface():
+    if MATPLOTLIB_3D_SURFACE:
+        fig = plt.figure(figsize=(10, 8))
+        ax = fig.add_subplot(111, projection="3d")
+        R = np.linspace(0.1, 5, 100)
+        Z = np.linspace(0.1, 5, 100)
+        R, Z = np.meshgrid(R, Z)
+        E_magnitude = np.sqrt(E_R(R, Z)**2 + E_z(R, Z)**2)
+        potential = Phi(R, Z)
+
+        surf = ax.plot_surface(R, Z, E_magnitude, cmap="viridis", edgecolor="none", alpha=0.7)
+        fig.colorbar(surf, ax=ax, label="Electric field magnitude (V/m)", pad=0.1)
+        ax.contour(R, Z, potential, levels=15, offset=E_magnitude.min(), cmap="cool", linestyles="dashed")
+
+        ax.set_xlabel("R (m)")
+        ax.set_ylabel("Z (m)")
+        ax.set_zlabel("Electric Field Magnitude (V/m)")
+        ax.set_title("Electric Field Magnitude (3D Surface Plot) with Equipotential Contours")
+        plt.tight_layout()
+        plt.show()
 
-    cbar = plt.colorbar(
-        streamplot.lines,
-        label="Electric field magnitude (V/m)",
-        pad=PLOT_CONFIG["colorbar_pad"],
-    )
-    cbar.ax.tick_params(labelsize=PLOT_CONFIG["tick_label_size"])
-
-    ax.set_title("Electric Field Distribution (2D Streamplot)")
-    ax.set_xlabel("R (m)")
-    ax.set_ylabel("Z (m)")
-
-    # Set axis limits (optional, adjust as needed)
-    ax.set_xlim(PLOT_PARAMS["2d_streamplot"].get("x_lim", (R.min(), R.max())))
-    ax.set_ylim(PLOT_PARAMS["2d_streamplot"].get("y_lim", (Z.min(), Z.max())))
-
-    # Add a text annotation for the scale (optional)
-    if PLOT_PARAMS["2d_streamplot"].get("show_scale", True):
-        scale_text = f"Scale: {scale_factor:.1e} m/arrow"
-        ax.text(
-            0.05,
-            0.95,
-            scale_text,
-            transform=ax.transAxes,
-            fontsize=8,
-            verticalalignment="top",
+# Plotly Interactive 3D Surface Plot
+def plotly_3d_surface():
+    if PLOTLY_3D_SURFACE:
+        R = np.linspace(0.1, 5, 100)
+        Z = np.linspace(0.1, 5, 100)
+        R, Z = np.meshgrid(R, Z)
+        E_magnitude = np.sqrt(E_R(R, Z)**2 + E_z(R, Z)**2)
+
+        fig = go.Figure(data=[go.Surface(z=E_magnitude, x=R, y=Z, colorscale='Viridis')])
+        fig.update_layout(
+            title="Electric Field Magnitude",
+            scene=dict(
+                xaxis_title="R (m)",
+                yaxis_title="Z (m)",
+                zaxis_title="Field Magnitude (V/m)"
+            ),
         )
-
-    plt.tight_layout()
-    save_plot(fig, "2d_streamplot")
-
-
-def create_2d_contour_plot():
-    fig, ax = plt.subplots(figsize=PLOT_CONFIG["figure_size"])
-
-    # Assuming R and Z are in meters
-    R = np.linspace(
-        *PLOT_PARAMS["2d_contour"]["R_range"], PLOT_PARAMS["2d_contour"]["grid_size"]
-    )
-    Z = np.linspace(
-        *PLOT_PARAMS["2d_contour"]["Z_range"], PLOT_PARAMS["2d_contour"]["grid_size"]
-    )
-    R, Z = np.meshgrid(R, Z)
-
-    E_R_values = E_R(R, Z)  # Assuming E_R returns values in V/m
-    E_z_values = E_z(R, Z)  # Assuming E_z returns values in V/m
-    E_magnitude = np.sqrt(E_R_values**2 + E_z_values**2)
-
-    # Create contour levels
-    if isinstance(PLOT_PARAMS["2d_contour"]["contour_levels"], int):
-        levels = np.linspace(
-            E_magnitude.min(),
-            E_magnitude.max(),
-            PLOT_PARAMS["2d_contour"]["contour_levels"],
+        fig.show()
+
+# Mayavi 3D Vector Field
+def mayavi_vector_field():
+    if MAYAVI_VECTOR_FIELD:
+        R = np.linspace(-5, 5, 10)
+        Z = np.linspace(-5, 5, 10)
+        R, Z = np.meshgrid(R, Z)
+        E_R_values = E_R(R, Z)
+        E_z_values = E_z(R, Z)
+
+        mlab.figure(size=(800, 600))
+        mlab.quiver3d(R, Z, np.zeros_like(R), E_R_values, E_z_values, np.zeros_like(R), color=(0, 0, 1))
+        mlab.title("Electric Field Vector Field")
+        mlab.xlabel("R")
+        mlab.ylabel("Z")
+        mlab.show()
+
+# PyVista Streamlines
+def pyvista_streamlines():
+    if PYVISTA_STREAMLINES:
+        R = np.linspace(-5, 5, 50)
+        Z = np.linspace(-5, 5, 50)
+        R, Z = np.meshgrid(R, Z)
+        E_R_values = E_R(R, Z)
+        E_z_values = E_z(R, Z)
+        potential = Phi(R, Z)
+
+        grid = pv.StructuredGrid(R, Z, np.zeros_like(R))
+        grid['E_field'] = np.c_[E_R_values.ravel(), E_z_values.ravel(), np.zeros_like(E_R_values).ravel()]
+        grid['potential'] = potential.ravel()
+
+        # Create a source point for the streamlines
+        source = pv.PolyData([0, 0, 0])
+
+        plotter = pv.Plotter()
+        plotter.add_mesh(grid.contour(10, scalars='potential'), cmap='coolwarm', line_width=2)
+        streamlines = grid.streamlines_from_source(
+            source, vectors='E_field', max_time=100, integration_direction='both'
         )
-    else:
-        levels = PLOT_PARAMS["2d_contour"]["contour_levels"]
-
-    contour = ax.contourf(
-        R,
-        Z,
-        E_magnitude,
-        levels=levels,
-        cmap=PLOT_PARAMS["2d_contour"].get("cmap", "viridis"),
+        plotter.add_mesh(streamlines.tube(radius=0.01), color='blue')
+        plotter.add_mesh(grid.outline(), color="k")
+        plotter.show()
+
+# Holoviews + Datashader High-Resolution Quiver Plot
+def holoviews_vectorfield_plot():
+    # Increase the resolution for smoother contours and vector fields
+    R = np.linspace(-5, 5, 100)
+    Z = np.linspace(-5, 5, 100)
+    R, Z = np.meshgrid(R, Z)
+    E_R_values = E_R(R, Z)
+    E_z_values = E_z(R, Z)
+    potential_values = Phi(R, Z)
+
+    # Prepare vector data for the plot
+    vector_data = (R.ravel(), Z.ravel(), E_R_values.ravel(), E_z_values.ravel())
+    
+    # Create a VectorField plot with adjusted scaling and no colorbar
+    vector_field = hv.VectorField(vector_data).opts(
+        magnitude='Magnitude', color='Magnitude', cmap='Viridis',
+        width=600, height=600, scale=0.5, colorbar=False
     )
-
-    if PLOT_PARAMS["2d_contour"].get("show_contour_lines", False):
-        ax.contour(R, Z, E_magnitude, levels=levels, colors="k", linewidths=0.5)
-
-    cbar = plt.colorbar(
-        contour, label="Electric field magnitude (V/m)", pad=PLOT_CONFIG["colorbar_pad"]
+    
+    # Manually set contour levels
+    contour_levels = np.linspace(potential_values.min(), potential_values.max(), 20)
+    
+    # Create a contour plot for the potential with enhanced lines and no labels
+    contour = hv.operation.contours(hv.Image((R[0], Z[:, 0], potential_values)), levels=contour_levels).opts(
+        cmap='Blues', line_width=2, alpha=0.8, colorbar=False, show_legend=False
     )
-    cbar.ax.tick_params(labelsize=PLOT_CONFIG["tick_label_size"])
-
-    ax.set_title("Electric Field Distribution (2D Contour)")
-    ax.set_xlabel("R (m)")
-    ax.set_ylabel("Z (m)")
-
-    # Set axis limits (optional, adjust as needed)
-    ax.set_xlim(PLOT_PARAMS["2d_contour"].get("x_lim", (R.min(), R.max())))
-    ax.set_ylim(PLOT_PARAMS["2d_contour"].get("y_lim", (Z.min(), Z.max())))
-
-    # Add a text annotation for the contour levels (optional)
-    if PLOT_PARAMS["2d_contour"].get("show_contour_info", True):
-        contour_info = f"Contour levels: {len(levels)}"
-        ax.text(
-            0.05,
-            0.95,
-            contour_info,
-            transform=ax.transAxes,
-            fontsize=8,
-            verticalalignment="top",
-        )
-
-    plt.tight_layout()
-    save_plot(fig, "2d_contour")
-
-
-# Main execution
-
+    
+    # Overlay VectorField and Contour
+    plot = vector_field * contour
+    
+    return plot
 
+# Main function to generate plots
 def main():
-    print_section("Electric Field Plot Generation")
-    print(f"{Fore.YELLOW}Starting plot generation...{Style.RESET_ALL}")
-
-    plot_functions = [
-        ("3D Quiver", create_3d_quiver_plot),
-        ("3D Contour", create_3d_contour_plot),
-        ("2D Streamplot", create_2d_streamplot),
-        ("2D Contour", create_2d_contour_plot),
-    ]
-
-    for plot_type, plot_func in plot_functions:
-        create_plot(plot_type, plot_func)
-
-    print_section("Plot Generation Complete")
-    print(
-        f"{Fore.GREEN}All plots have been saved in the '{
-          PLOT_CONFIG['output_folder']}' folder.{Style.RESET_ALL}"
-    )
-
+    if MATPLOTLIB_2D_STREAM_CONTOUR:
+        matplotlib_2d_stream_contour()
+    if MATPLOTLIB_2D_QUIVER:
+        matplotlib_2d_quiver()
+    if MATPLOTLIB_3D_SURFACE:
+        matplotlib_3d_surface()
+    if MATPLOTLIB_2D_POTENTIAL_CONTOUR:
+        matplotlib_2d_potential_contour()
+    if MATPLOTLIB_2D_ELECTRIC_CONTOUR:
+        matplotlib_2d_electric_field_contour()
+    if PLOTLY_3D_SURFACE:
+        plotly_3d_surface()
+    if MAYAVI_VECTOR_FIELD:
+        mayavi_vector_field()
+    if PYVISTA_STREAMLINES:
+        pyvista_streamlines()
+    if HOLOVIEWS_QUAD_MESH:
+        plot = holoviews_vectorfield_plot()
+        hv.save(plot, 'quiver_contour_plot.html', backend='bokeh')
 
 if __name__ == "__main__":
-    try:
-        main()
-    except Exception as e:
-        print(f"{Fore.RED}An unexpected error occurred: {e}{Style.RESET_ALL}")
-        sys.exit(1)
+    main()
\ No newline at end of file
diff --git a/requirements.txt b/requirements.txt
index 896d8af..ed3e038 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -8,4 +8,11 @@ numpy
 scipy
 seaborn
 colorama
-pyyaml
\ No newline at end of file
+pyyaml
+mayavi
+pyvista
+holoviews
+datashader
+bokeh
+vtk
+PyQt5
\ No newline at end of file
